Sistema de Reglas Generales para Revisi√≥n de Informes M√©dicos
Aseguradoras Privadas M√©xico - Auditable 100%
Versi√≥n: 4.0 - Sin Alucinaciones
Fecha: Diciembre 2024
Principio Core: IF [condici√≥n literal] THEN [resultado espec√≠fico]. Nada m√°s.

PROP√ìSITO
Este sistema proporciona reglas booleanas simples para:

‚úÖ Detectar campos faltantes o con formato inv√°lido
‚úÖ Detectar inconsistencias l√≥gicas entre fechas/n√∫meros
‚úÖ Generar un score basado en reglas ejecutables
‚úÖ Ser 100% auditable: "¬øPor qu√© fall√≥?" ‚Üí respuesta directa en el c√≥digo

Restricci√≥n:

üö´ NO hacer b√∫squedas de mercado
üö´ NO inferir diagn√≥sticos
üö´ NO validar "coherencia cl√≠nica" (eso es trabajo del m√©dico)
üö´ NO comparar sem√°nticamente textos
üö´ NO puntuar por falta de datos que no son obligatorios


ESTRUCTURA DE REGLA
typescriptinterface ScoringRule {
  id: string;                              // ID √∫nico
  name: string;                            // Descripci√≥n legible
  category: 'IDENTIDAD' | 'TEMPORAL' | 'COMPLETITUD' | 'DOCUMENTACI√ìN' | 'COHERENCIA_DATOS';
  level: 'CR√çTICA' | 'IMPORTANTE' | 'MODERADA' | 'NOTA';
  points: number;                          // Puntos negativos (siempre ‚â§ 0)
  affectedFields: string[];                // Qu√© campos afecta
  condition: string;                       // Descripci√≥n IF en espa√±ol legible
  validator: (data: ExtractedData) => {
    passed: boolean;                       // true si PASA, false si FALLA
    reason?: string;                       // Exactamente QU√â fall√≥
    evidence?: string;                     // Datos concretos
  };
  message: string;                         // Al revisor: "Falta [X]" o "Campo [Y] contiene [Z]"
  applicableIf?: (data: ExtractedData) => boolean;  // Regla aplica solo si...
}

CATEGOR√çA 1: IDENTIDAD
Prop√≥sito
Validar que se pueden identificar el paciente, m√©dico y p√≥liza.

CR√çTICA 1.1 | paciente_nombre_minimo
IF: (nombres.length < 2) OR (primer_apellido.length < 2)
THEN: FALLA
Points: -100

Campos afectados: identificacion.nombres, identificacion.primer_apellido
Validator:

typescript  validator: (data) => {
    const nombres = data.identificacion?.nombres || '';
    const apellido1 = data.identificacion?.primer_apellido || '';
    
    if (nombres.length < 2 || apellido1.length < 2) {
      return {
        passed: false,
        reason: 'Nombre o apellido demasiado corto',
        evidence: `Nombres: "${nombres}" (${nombres.length} chars), Apellido1: "${apellido1}" (${apellido1.length} chars)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Nombre del paciente incompleto. Se requiere m√≠nimo 2 caracteres en nombre Y 2 en primer apellido. Actual: [nombres] [apellido1]"
¬øPor qu√© cr√≠tica?: Sin identidad clara no se puede procesar la p√≥liza.


CR√çTICA 1.2 | poliza_numero_presente
IF: (poliza.numero === NULL OR poliza.numero === '' OR poliza.numero.length < 5)
THEN: FALLA
Points: -100

Campos afectados: poliza.numero
Validator:

typescript  validator: (data) => {
    const numPoliza = data.poliza?.numero || '';
    
    if (!numPoliza || numPoliza.length < 5) {
      return {
        passed: false,
        reason: 'N√∫mero de p√≥liza ausente o demasiado corto',
        evidence: `P√≥liza: "${numPoliza}" (${numPoliza.length} caracteres)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "N√∫mero de p√≥liza faltante o con menos de 5 caracteres. Requerido para validar cobertura."
¬øPor qu√© cr√≠tica?: Sin p√≥liza, no hay contrato.


CR√çTICA 1.3 | medico_nombres_minimo
IF: (nombres.length < 2) OR (primer_apellido.length < 2)
THEN: FALLA
Points: -100

Campos afectados: medico_tratante.nombres, medico_tratante.primer_apellido
Validator:

typescript  validator: (data) => {
    const nombres = data.medico_tratante?.nombres || '';
    const apellido1 = data.medico_tratante?.primer_apellido || '';
    
    if (nombres.length < 2 || apellido1.length < 2) {
      return {
        passed: false,
        reason: 'Nombre del m√©dico incompleto',
        evidence: `Nombres: "${nombres}" (${nombres.length} chars), Apellido1: "${apellido1}" (${apellido1.length} chars)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Nombre del m√©dico tratante incompleto. Se requiere m√≠nimo 2 caracteres en nombre Y 2 en primer apellido."


CR√çTICA 1.4 | cedula_profesional_formato
IF: (cedula_profesional === NULL OR cedula_profesional === '' 
     OR NOT MATCH(/^\d{7,8}$/))
THEN: FALLA
Points: -100

Campos afectados: medico_tratante.cedula_profesional
Validator:

typescript  validator: (data) => {
    const cedula = data.medico_tratante?.cedula_profesional || '';
    const pattern = /^\d{7,8}$/;
    
    if (!cedula || !pattern.test(cedula)) {
      return {
        passed: false,
        reason: 'C√©dula profesional no cumple formato',
        evidence: `C√©dula: "${cedula}". Esperado: 7-8 d√≠gitos num√©ricos. Actual: ${cedula.length} caracteres`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "C√©dula profesional del m√©dico inv√°lida. Debe ser 7-8 d√≠gitos num√©ricos. Actual: [cedula]"


CR√çTICA 1.5 | especialidad_presente
IF: (especialidad === NULL OR especialidad === '')
THEN: FALLA
Points: -100

Campos afectados: medico_tratante.especialidad
Validator:

typescript  validator: (data) => {
    const especialidad = data.medico_tratante?.especialidad || '';
    
    if (!especialidad) {
      return {
        passed: false,
        reason: 'Especialidad del m√©dico no especificada',
        evidence: `Campo vac√≠o`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Especialidad del m√©dico tratante no especificada. Requerida para validar competencia con procedimiento."


CR√çTICA 1.6 | firma_medico_presente
IF: (firma === NULL OR firma === '')
THEN: FALLA
Points: -100

Campos afectados: medico_tratante.firma, medico_tratante.sello
Validator:

typescript  validator: (data) => {
    const firma = data.medico_tratante?.firma || '';
    const sello = data.medico_tratante?.sello || '';
    
    if (!firma && !sello) {
      return {
        passed: false,
        reason: 'Sin firma o sello del m√©dico',
        evidence: `Firma: ${firma ? 'presente' : 'ausente'}, Sello: ${sello ? 'presente' : 'ausente'}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Informe sin firma o sello del m√©dico tratante. Requerido como evidencia de autor√≠a."


CR√çTICA 1.7 | edad_rango_vital
IF: (edad < 0 OR edad > 120 OR edad === NULL)
THEN: FALLA
Points: -100

Campos afectados: identificacion.edad
Validator:

typescript  validator: (data) => {
    const edad = data.identificacion?.edad;
    
    if (edad === null || edad === undefined || edad < 0 || edad > 120) {
      return {
        passed: false,
        reason: 'Edad fuera de rango vital',
        evidence: `Edad: ${edad}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Edad del paciente inv√°lida. Debe estar entre 0 y 120 a√±os. Actual: [edad]"


CR√çTICA 1.8 | sexo_valor_valido
IF: (sexo NOT IN ['M', 'F', 'O'] OR sexo === NULL)
THEN: FALLA
Points: -100

Campos afectados: identificacion.sexo
Validator:

typescript  validator: (data) => {
    const sexo = data.identificacion?.sexo || '';
    const validos = ['M', 'F', 'O'];
    
    if (!validos.includes(sexo)) {
      return {
        passed: false,
        reason: 'Sexo inv√°lido o no especificado',
        evidence: `Sexo: "${sexo}". V√°lidos: M, F, O`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Sexo del paciente inv√°lido. Debe ser: M (Masculino), F (Femenino) o O (Otro). Actual: [sexo]"



CATEGOR√çA 2: TEMPORAL (COHERENCIA DE FECHAS)
Prop√≥sito
Validar que las fechas tengan orden l√≥gico: no se puede egresar antes de ingresar.

CR√çTICA 2.1 | ingreso_anterior_egreso
IF: (fecha.egreso < fecha.ingreso AND ambas existen)
THEN: FALLA
Points: -100

Aplicable si: atencion.tipo IN ['hospitalaria', 'urgencias']
Campos afectados: fecha.ingreso, fecha.egreso
Validator:

typescript  validator: (data) => {
    const ingreso = data.fecha?.ingreso ? new Date(data.fecha.ingreso) : null;
    const egreso = data.fecha?.egreso ? new Date(data.fecha.egreso) : null;
    
    if (ingreso && egreso && egreso < ingreso) {
      return {
        passed: false,
        reason: 'Fecha de egreso anterior a ingreso',
        evidence: `Ingreso: ${ingreso.toISOString().split('T')[0]}, Egreso: ${egreso.toISOString().split('T')[0]}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Inconsistencia de fechas: Egreso ([egreso]) es anterior a Ingreso ([ingreso]). Imposible l√≥gicamente."


CR√çTICA 2.2 | diagnostico_no_futuro
IF: (fecha.diagnostico > HOY())
THEN: FALLA
Points: -100

Campos afectados: diagnostico.fecha
Validator:

typescript  validator: (data) => {
    const diagnosticoFecha = data.diagnostico?.fecha 
      ? new Date(data.diagnostico.fecha) 
      : null;
    const hoy = new Date();
    
    if (diagnosticoFecha && diagnosticoFecha > hoy) {
      return {
        passed: false,
        reason: 'Diagn√≥stico con fecha futura',
        evidence: `Fecha diagn√≥stico: ${diagnosticoFecha.toISOString().split('T')[0]}, Hoy: ${hoy.toISOString().split('T')[0]}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Diagn√≥stico fechado en el futuro ([fecha]). No es posible diagnosticar algo que a√∫n no ocurre."


CR√çTICA 2.3 | cirugia_dentro_hospitalizacion
IF: (cirugia === TRUE 
     AND (fecha.cirugia < fecha.ingreso OR fecha.cirugia > fecha.egreso))
THEN: FALLA
Points: -100

Aplicable si: intervencion_qx.cirugia === TRUE
Campos afectados: intervencion_qx.fecha_cirugia, fecha.ingreso, fecha.egreso
Validator:

typescript  validator: (data) => {
    if (!data.intervencion_qx?.cirugia) return { passed: true }; // No aplica
    
    const cirugia = data.intervencion_qx.fecha_cirugia 
      ? new Date(data.intervencion_qx.fecha_cirugia) 
      : null;
    const ingreso = data.fecha?.ingreso ? new Date(data.fecha.ingreso) : null;
    const egreso = data.fecha?.egreso ? new Date(data.fecha.egreso) : null;
    
    if (cirugia && ingreso && egreso) {
      if (cirugia < ingreso || cirugia > egreso) {
        return {
          passed: false,
          reason: 'Cirug√≠a fuera del per√≠odo de hospitalizaci√≥n',
          evidence: `Cirug√≠a: ${cirugia.toISOString().split('T')[0]}, Ingreso: ${ingreso.toISOString().split('T')[0]}, Egreso: ${egreso.toISOString().split('T')[0]}`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "Fecha de cirug√≠a ([cirugia]) est√° fuera del per√≠odo de hospitalizaci√≥n ([ingreso] a [egreso])."
Excepci√≥n: Si es cirug√≠a ambulatoria (estancia = 0), fecha_cirugia puede = fecha_egreso


CR√çTICA 2.4 | informe_posterior_a_eventos
IF: (fecha.informe < MAX(fecha.egreso, fecha.cirugia, fecha.diagnostico))
THEN: FALLA
Points: -100

Campos afectados: fecha.informe, fecha.egreso, intervencion_qx.fecha_cirugia, diagnostico.fecha
Validator:

typescript  validator: (data) => {
    const informe = data.fecha?.informe ? new Date(data.fecha.informe) : null;
    const egreso = data.fecha?.egreso ? new Date(data.fecha.egreso) : null;
    const cirugia = data.intervencion_qx?.fecha_cirugia 
      ? new Date(data.intervencion_qx.fecha_cirugia) 
      : null;
    const diagnostico = data.diagnostico?.fecha 
      ? new Date(data.diagnostico.fecha) 
      : null;
    
    if (informe) {
      const eventos = [egreso, cirugia, diagnostico].filter(f => f !== null);
      const maxEvento = eventos.length > 0 ? new Date(Math.max(...eventos)) : null;
      
      if (maxEvento && informe < maxEvento) {
        return {
          passed: false,
          reason: 'Informe anterior a eventos reportados',
          evidence: `Informe: ${informe.toISOString().split('T')[0]}, Evento m√°ximo: ${maxEvento.toISOString().split('T')[0]}`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "El informe est√° fechado ([informe]) anterior a eventos en el documento (m√°ximo: [evento]). No es posible escribir sobre algo que ocurri√≥ despu√©s."


PR√ìXIMA INTEGRACI√ìN 2.5 | poliza_vigencia_valida (DESACTIVADA)
NOTA: Regla pendiente de integraci√≥n cuando se conecte a base de datos del broker.
Cuando est√© activa:
  IF: (fecha.informe < poliza.vigencia_inicio OR fecha.informe > poliza.vigencia_fin)
  THEN: FALLA (CR√çTICA)
  Points: -100

Estado actual: PENDIENTE
Activaci√≥n: Cuando se tenga acceso a tabla de p√≥lizas con vigencia_inicio y vigencia_fin
Mensaje futuro: "Informe ([fecha]) est√° fuera de la vigencia de p√≥liza ([inicio] a [fin]). Sin cobertura."


IMPORTANTE 2.6 | estancia_dias_razonable
IF: (estancia.dias < 0)
THEN: FALLA (cr√≠tica)
Points: -100

IF: (estancia.dias > 365 AND atencion.tipo !== 'cr√≥nica')
THEN: ALERTA
Points: -30

Aplicable si: fecha.ingreso Y fecha.egreso existen
Campos afectados: estancia.dias, fecha.ingreso, fecha.egreso
Validator:

typescript  validator: (data) => {
    const ingreso = data.fecha?.ingreso ? new Date(data.fecha.ingreso) : null;
    const egreso = data.fecha?.egreso ? new Date(data.fecha.egreso) : null;
    
    if (ingreso && egreso) {
      const dias = Math.floor((egreso - ingreso) / (1000 * 60 * 60 * 24));
      
      if (dias < 0) {
        return {
          passed: false,
          reason: 'D√≠as negativos (egreso antes de ingreso)',
          evidence: `C√°lculo: ${dias} d√≠as`
        };
      }
      
      if (dias > 365 && data.atencion?.tipo !== 'cr√≥nica') {
        return {
          passed: false,
          reason: 'Estancia muy prolongada (>365 d√≠as)',
          evidence: `D√≠as calculados: ${dias}`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "Estancia muy larga ([dias] d√≠as). Si no es caso cr√≥nico, requiere justificaci√≥n."



CATEGOR√çA 3: COMPLETITUD (CAMPOS OBLIGATORIOS)
Prop√≥sito
Validar que informaci√≥n cr√≠tica no est√© ausente.

CR√çTICA 3.1 | diagnostico_principal_presente
IF: (diagnostico.definitivo === NULL OR diagnostico.definitivo === '' 
     OR diagnostico.definitivo.length < 10)
THEN: FALLA
Points: -100

Campos afectados: diagnostico.definitivo
Validator:

typescript  validator: (data) => {
    const diagnostico = data.diagnostico?.definitivo || '';
    
    if (!diagnostico || diagnostico.length < 10) {
      return {
        passed: false,
        reason: 'Diagn√≥stico insuficiente',
        evidence: `Diagn√≥stico: "${diagnostico}" (${diagnostico.length} caracteres). M√≠nimo: 10`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Diagn√≥stico principal incompleto. M√≠nimo 10 caracteres descriptivos. Actual: [diagnostico]"


CR√çTICA 3.2 | tipo_atencion_presente
IF: (atencion.tipo NOT IN ['ambulatoria', 'hospitalaria', 'urgencias', 'cr√≥nica', 'preventiva']
     OR atencion.tipo === NULL)
THEN: FALLA
Points: -100

Campos afectados: atencion.tipo
Validator:

typescript  validator: (data) => {
    const tipo = data.atencion?.tipo || '';
    const validos = ['ambulatoria', 'hospitalaria', 'urgencias', 'cr√≥nica', 'preventiva'];
    
    if (!validos.includes(tipo)) {
      return {
        passed: false,
        reason: 'Tipo de atenci√≥n no v√°lido o ausente',
        evidence: `Tipo: "${tipo}". V√°lidos: ${validos.join(', ')}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Tipo de atenci√≥n no especificado o inv√°lido. Seleccionar: Ambulatoria, Hospitalaria, Urgencias, Cr√≥nica o Preventiva."


CR√çTICA 3.3 | codigo_cie10_presente
IF: (diagnostico.codigo_cie === NULL OR diagnostico.codigo_cie === '')
THEN: FALLA
Points: -100

Campos afectados: diagnostico.codigo_cie
Validator:

typescript  validator: (data) => {
    const cie = data.diagnostico?.codigo_cie || '';
    
    if (!cie) {
      return {
        passed: false,
        reason: 'C√≥digo CIE-10 ausente',
        evidence: `Campo vac√≠o`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "C√≥digo CIE-10 no especificado. Requerido para identificar diagn√≥stico."


IMPORTANTE 3.4 | cie10_formato_valido
IF: (codigo_cie NOT MATCH(/^[A-Z]\d{2}(\.\d{1,2})?$/))
THEN: ALERTA (nota informativa)
Points: 0 (solo nota)

Campos afectados: diagnostico.codigo_cie
Validator:

typescript  validator: (data) => {
    const cie = data.diagnostico?.codigo_cie || '';
    const pattern = /^[A-Z]\d{2}(\.\d{1,2})?$/;
    
    if (cie && !pattern.test(cie)) {
      return {
        passed: false,
        reason: 'CIE-10 no cumple formato esperado',
        evidence: `CIE: "${cie}". Esperado: Letra + 2 d√≠gitos [+ punto + 1-2 d√≠gitos]. Ej: J44.9, E10.90`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "NOTA INFORMATIVA: C√≥digo CIE-10 '[codigo]' no cumple formato esperado (Letra + 2 d√≠gitos + opcionalmente punto + 1-2 d√≠gitos). Verifique si es error de OCR. Esperado: [formato]"
¬øPor qu√© es nota?: No es una falla definitiva, pero el revisor debe verificar manualmente


CR√çTICA 3.5 | hospital_nombre_si_hospitalizacion
IF: (atencion.tipo === 'hospitalaria' AND (hospital.nombre === NULL OR hospital.nombre === ''))
THEN: FALLA
Points: -100

Aplicable si: atencion.tipo === 'hospitalaria'
Campos afectados: hospital.nombre
Validator:

typescript  validator: (data) => {
    if (data.atencion?.tipo !== 'hospitalaria') return { passed: true };
    
    const nombreHospital = data.hospital?.nombre || '';
    
    if (!nombreHospital) {
      return {
        passed: false,
        reason: 'Hospital no identificado en hospitalizaci√≥n',
        evidence: `Campo vac√≠o`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Tipo de atenci√≥n es 'hospitalaria' pero hospital no est√° identificado. Ingrese nombre y preferentemente clave COFEPRIS."


IMPORTANTE 3.6 | reclamacion_monto_presente
IF: (reclamacion.monto_solicitado === NULL 
     OR reclamacion.monto_solicitado === 0
     OR reclamacion.monto_solicitado < 0)
THEN: FALLA
Points: -50

Campos afectados: reclamacion.monto_solicitado
Validator:

typescript  validator: (data) => {
    const monto = data.reclamacion?.monto_solicitado;
    
    if (monto === null || monto === undefined || monto <= 0) {
      return {
        passed: false,
        reason: 'Monto de reclamaci√≥n ausente o inv√°lido',
        evidence: `Monto: ${monto}`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Monto de reclamaci√≥n no especificado o es cero. Ingrese cantidad a reclamar (>0)."



CATEGOR√çA 4: DOCUMENTACI√ìN
Prop√≥sito
Validar que documentos probatorios est√©n presentes.

NOTA 4.1 | hospital_sello_presente
IF: (atencion.tipo === 'hospitalaria' AND (hospital.sello === NULL OR hospital.sello === ''))
THEN: NOTA INFORMATIVA (no penaliza)
Points: 0

Aplicable si: atencion.tipo === 'hospitalaria'
Campos afectados: hospital.sello
Validator:

typescript  validator: (data) => {
    if (data.atencion?.tipo !== 'hospitalaria') return { passed: true };
    
    const sello = data.hospital?.sello || '';
    
    if (!sello) {
      return {
        passed: false,
        reason: 'Sello del hospital no visible',
        evidence: `Campo vac√≠o`,
        isNoteOnly: true  // Informaci√≥n solamente, no penaliza
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "NOTA: Sello del hospital no visible en documento. Considere solicitar copia con sello si es cr√≠tico para validaci√≥n interna."
¬øPor qu√© nota?: No es requisito obligatorio en esta fase. Se puede solicitar si el revisor lo considera necesario.


NOTA 4.2 | estudios_laboratorio_mencionados
IF: (cirugia === TRUE 
     AND (estudios.laboratorio === NULL OR estudios.laboratorio === ''))
THEN: NOTA INFORMATIVA (no penaliza)
Points: 0

Aplicable si: intervencion_qx.cirugia === TRUE
Campos afectados: estudios.laboratorio
Validator:

typescript  validator: (data) => {
    if (!data.intervencion_qx?.cirugia) return { passed: true };
    
    const laboratorio = data.estudios?.laboratorio || '';
    
    if (!laboratorio) {
      return {
        passed: false,
        reason: 'Estudios de laboratorio no mencionados en informe',
        evidence: `Campo vac√≠o`,
        isNoteOnly: true  // Informaci√≥n solamente, no penaliza
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "NOTA: Cirug√≠a reportada pero estudios de laboratorio no est√°n mencionados en el informe. Si est√°n incluidos, especificar resultados relevantes en el documento."
¬øPor qu√© nota?: En esta fase se especifican dentro del mismo informe (no como anexo). Si el revisor ve que est√°n documentados en el texto, no hay penalizaci√≥n. Es solo un recordatorio de verificar que est√©n incluidos.


IMPORTANTE 4.3 | notas_evolucion_si_hospitalizacion_larga
IF: (atencion.tipo === 'hospitalaria' 
     AND estancia.dias > 3 
     AND (notas.evolucion === NULL OR notas.evolucion === ''))
THEN: FALLA
Points: -40

Aplicable si: atencion.tipo === 'hospitalaria' Y estancia.dias > 3
Campos afectados: notas.evolucion
Validator:

typescript  validator: (data) => {
    if (data.atencion?.tipo !== 'hospitalaria') return { passed: true };
    
    const estancia = data.estancia?.dias || 0;
    if (estancia <= 3) return { passed: true };
    
    const notas = data.notas?.evolucion || '';
    
    if (!notas) {
      return {
        passed: false,
        reason: 'Notas de evoluci√≥n ausentes en hospitalizaci√≥n >3 d√≠as',
        evidence: `Estancia: ${estancia} d√≠as, Notas: vac√≠o`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Hospitalizaci√≥n de [dias] d√≠as sin notas de evoluci√≥n adjuntas. Requeridas para validar curso cl√≠nico."



CATEGOR√çA 5: COHERENCIA DE DATOS
Prop√≥sito
Validar que valores espec√≠ficos sean l√≥gicamente posibles (sin interpretar cl√≠nica).

CR√çTICA 5.1 | sexo_compatible_diagnostico_obstetricia
IF: (sexo === 'M' AND codigo_cie STARTS WITH 'O')
THEN: FALLA
Points: -100

Campos afectados: identificacion.sexo, diagnostico.codigo_cie
Validator:

typescript  validator: (data) => {
    const sexo = data.identificacion?.sexo || '';
    const cie = data.diagnostico?.codigo_cie || '';
    
    if (sexo === 'M' && cie.startsWith('O')) {
      return {
        passed: false,
        reason: 'Diagn√≥stico obst√©trico en paciente masculino',
        evidence: `Sexo: M, CIE-10: ${cie} (rango O=Embarazo/parto/puerperio)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "IMPOSIBILIDAD L√ìGICA: Diagn√≥stico obst√©trico '[cie]' en paciente sexo Masculino. Error de datos o de OCR."


CR√çTICA 5.2 | sexo_compatible_diagnostico_prostatico
IF: (sexo === 'F' AND codigo_cie IN ['N40', 'N41', 'N42', 'N43', 'N44', 'N45', 'N46', 'N47', 'N48', 'N49', 'N50', 'N51', 'C61'])
THEN: FALLA
Points: -100

Campos afectados: identificacion.sexo, diagnostico.codigo_cie
Validator:

typescript  validator: (data) => {
    const sexo = data.identificacion?.sexo || '';
    const cie = data.diagnostico?.codigo_cie || '';
    
    const diagnosticosProstatica = ['N40', 'N41', 'N42', 'N43', 'N44', 'N45', 'N46', 'N47', 'N48', 'N49', 'N50', 'N51', 'C61'];
    const esProstatica = diagnosticosProstatica.some(d => cie.startsWith(d));
    
    if (sexo === 'F' && esProstatica) {
      return {
        passed: false,
        reason: 'Diagn√≥stico de pr√≥stata en paciente femenino',
        evidence: `Sexo: F, CIE-10: ${cie} (afecci√≥n de pr√≥stata)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "IMPOSIBILIDAD L√ìGICA: Diagn√≥stico de pr√≥stata '[cie]' en paciente sexo Femenino. Error de datos o de OCR."


IMPORTANTE 5.3 | temperatura_rango_extremo
IF: (temperatura < 32 OR temperatura > 43)
THEN: FALLA (cr√≠tica como nota)
Points: -50

Campos afectados: signos_vitales.temperatura
Validator:

typescript  validator: (data) => {
    const temp = data.signos_vitales?.temperatura;
    
    if (temp !== null && temp !== undefined) {
      if (temp < 32 || temp > 43) {
        return {
          passed: false,
          reason: 'Temperatura en rango incompatible con vida',
          evidence: `Temperatura: ${temp}¬∞C. Rango vital: 32-43¬∞C`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "Temperatura registrada: [temp]¬∞C. Fuera de rango compatible con vida (32-43¬∞C). ¬øError de OCR?"


IMPORTANTE 5.4 | frecuencia_cardiaca_rango_extremo
IF: (fc < 20 OR fc > 250)
THEN: FALLA
Points: -50

Campos afectados: signos_vitales.frecuencia_cardiaca
Validator:

typescript  validator: (data) => {
    const fc = data.signos_vitales?.frecuencia_cardiaca;
    
    if (fc !== null && fc !== undefined) {
      if (fc < 20 || fc > 250) {
        return {
          passed: false,
          reason: 'Frecuencia card√≠aca en rango extremo',
          evidence: `FC: ${fc} lpm. Rango vital: 20-250 lpm`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "Frecuencia card√≠aca registrada: [fc] lpm. Fuera de rango vital (20-250). ¬øError de OCR?"


IMPORTANTE 5.5 | presion_arterial_sistolica_rango_extremo
IF: (pa_sistolica < 50 OR pa_sistolica > 250)
THEN: FALLA
Points: -50

Campos afectados: signos_vitales.presion_arterial_sistolica
Validator:

typescript  validator: (data) => {
    const pas = data.signos_vitales?.presion_arterial_sistolica;
    
    if (pas !== null && pas !== undefined) {
      if (pas < 50 || pas > 250) {
        return {
          passed: false,
          reason: 'Presi√≥n arterial sist√≥lica en rango extremo',
          evidence: `PAS: ${pas} mmHg. Rango vital: 50-250 mmHg`
        };
      }
    }
    return { passed: true };
  }

Mensaje al revisor: "Presi√≥n arterial sist√≥lica registrada: [pas] mmHg. Fuera de rango vital (50-250). ¬øError de OCR?"


MODERADA 5.6 | complicaciones_documentadas_si_declaradas
IF: (complicaciones.declaradas === 'S√ç' 
     AND (complicaciones.descripcion === NULL OR complicaciones.descripcion.length < 10))
THEN: FALLA
Points: -20

Aplicable si: complicaciones.declaradas === 'S√ç'
Campos afectados: complicaciones.declaradas, complicaciones.descripcion
Validator:

typescript  validator: (data) => {
    if (data.complicaciones?.declaradas !== 'S√ç') return { passed: true };
    
    const desc = data.complicaciones?.descripcion || '';
    
    if (!desc || desc.length < 10) {
      return {
        passed: false,
        reason: 'Complicaciones declaradas pero insuficientemente descritas',
        evidence: `Declaradas: S√ç, Descripci√≥n: "${desc}" (${desc.length} caracteres, m√≠nimo 10)`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Complicaciones reportadas pero con descripci√≥n muy breve. M√≠nimo 10 caracteres. Actual: [descripcion]"


MODERADA 5.7 | anestesia_tipo_si_cirugia
IF: (cirugia === TRUE 
     AND (anestesia_tipo === NULL OR anestesia_tipo === ''))
THEN: FALLA
Points: -25

Aplicable si: intervencion_qx.cirugia === TRUE
Campos afectados: intervencion_qx.anestesia_tipo
Validator:

typescript  validator: (data) => {
    if (!data.intervencion_qx?.cirugia) return { passed: true };
    
    const tipo = data.intervencion_qx?.anestesia_tipo || '';
    
    if (!tipo) {
      return {
        passed: false,
        reason: 'Cirug√≠a reportada sin especificar tipo de anestesia',
        evidence: `Campo vac√≠o`
      };
    }
    return { passed: true };
  }

Mensaje al revisor: "Cirug√≠a declarada pero tipo de anestesia no especificado. Debe indicar: general, regional, local o sedaci√≥n."



C√ÅLCULO FINAL DE SCORE
F√≥rmula Simple
javascriptfunction calculateScore(rules, data) {
  let totalPoints = 0;
  let criticalCount = 0;
  let importantCount = 0;
  let moderateCount = 0;
  let noteCount = 0;
  const failedRules = [];
  const notes = [];  // Notas informativas por separado
  
  rules.forEach(rule => {
    // Validar si la regla aplica
    if (rule.applicableIf && !rule.applicableIf(data)) {
      return; // No aplica esta regla
    }
    
    const result = rule.validator(data);
    
    if (!result.passed) {
      // Si es una nota, no afecta puntos
      if (rule.level === 'NOTA' || result.isNoteOnly) {
        notes.push({
          ruleId: rule.id,
          name: rule.name,
          reason: result.reason,
          evidence: result.evidence,
          message: rule.message
        });
        noteCount++;
      } else {
        // Las cr√≠ticas, importantes y moderadas S√ç restan puntos
        totalPoints += rule.points;
        failedRules.push({
          ruleId: rule.id,
          name: rule.name,
          level: rule.level,
          points: rule.points,
          reason: result.reason,
          evidence: result.evidence,
          message: rule.message
        });
        
        switch(rule.level) {
          case 'CR√çTICA': criticalCount++; break;
          case 'IMPORTANTE': importantCount++; break;
          case 'MODERADA': moderateCount++; break;
        }
      }
    }
  });
  
  // Determinar estado
  let status = 'APPROVED';
  if (criticalCount > 0) {
    status = 'REJECTED';
  } else if (totalPoints <= -100) {
    status = 'REJECTED';
  } else if (totalPoints <= -50) {
    status = 'REVIEW';
  }
  
  // Aceptaci√≥n porcentual: 0 puntos = 100%, -200 puntos = 0%
  const acceptanceProbability = Math.max(0, Math.min(100, 100 + (totalPoints / 2)));
  
  return {
    status,
    acceptanceProbability: Math.round(acceptanceProbability),
    totalPoints,
    criticalIssues: criticalCount,
    importantIssues: importantCount,
    moderateIssues: moderateCount,
    noteIssues: noteCount,
    failedRules,          // Solo las que penalizan
    notes,                // Notas informativas (no penalizan)
    auditTrail: `${criticalCount} cr√≠ticas, ${importantCount} importantes, ${moderateCount} moderadas, ${noteCount} notas. Puntos: ${totalPoints}`
  };
}
Umbrales de Decisi√≥n
EscenarioDecisi√≥nCualquier regla CR√çTICA fallaRECHAZARPuntos ‚â§ -100RECHAZARPuntos -99 a -50REVISAR MANUALMENTEPuntos -49 a 0APROBAR (con observaciones)Puntos > 0APROBAR
Interpretaci√≥n Porcentual

90-100%: Informe excelente
70-89%: Informe con observaciones menores
50-69%: Informe requiere revisi√≥n humana
30-49%: Informe muy problem√°tico
0-29%: Informe cr√≠tico


NOTAS FINALES
‚úÖ 100% Auditable: Cada regla es IF/THEN con datos concretos
‚úÖ Cero Inferencias: Sin b√∫squedas de mercado, sin IA sem√°ntica
‚úÖ Cero Alucinaciones: Solo validaciones de formato y l√≥gica booleana
‚úÖ Transparente: El revisor humano ve exactamente por qu√© fall√≥
‚úÖ Defensible: Cada punto tiene evidencia literal del documento