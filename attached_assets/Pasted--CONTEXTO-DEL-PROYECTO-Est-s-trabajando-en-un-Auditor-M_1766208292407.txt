üìã CONTEXTO DEL PROYECTO
Est√°s trabajando en un Auditor M√©dico IA que procesa informes m√©dicos de dos aseguradoras mexicanas: GNP y MetLife. Cada aseguradora tiene formatos y requisitos diferentes.

Estado Actual del Sistema:
‚úÖ Extracci√≥n b√°sica funcionando con Gemini AI
‚úÖ Sistema de scoring con reglas generales
‚úÖ UI adaptativa que detecta el proveedor (provider: 'GNP' | 'METLIFE')
‚ö†Ô∏è PENDIENTE: Arquitectura config-driven centralizada
üéØ OBJETIVO PRINCIPAL
Implementar una arquitectura ProviderRegistry centralizada que permita:

Configuraci√≥n por proveedor (schemas, campos, reglas) en un solo lugar
Escalabilidad para agregar nuevas aseguradoras sin tocar m√∫ltiples archivos
Mantener el flujo existente: ProviderRegistry ‚Üí geminiService ‚Üí scoring-engine ‚Üí Dashboard
üìê ARQUITECTURA PROPUESTA (YA DISCUTIDA)
Estructura de Archivos:
services/
‚îú‚îÄ‚îÄ providerConfigs.ts  ‚Üê NUEVO: Registro central
‚îú‚îÄ‚îÄ geminiService.ts    ‚Üê Consume providerConfigs
‚îî‚îÄ‚îÄ scoring-engine.ts   ‚Üê Consume providerConfigs
Flujo de Datos:
PDF Upload ‚Üí Detectar Provider ‚Üí ProviderRegistry[provider]
‚Üí geminiService (usa schema del provider)
‚Üí scoring-engine (usa reglas del provider)
‚Üí Dashboard (renderiza campos del provider)
üóÇÔ∏è CAMPOS FALTANTES DE METLIFE
Seg√∫n el documento corregido compartido, faltan estos campos espec√≠ficos de MetLife:

Secci√≥n 2 (Antecedentes):
antecedentes.otras_afecciones (string)
Secci√≥n 3 (Padecimiento Actual):
exploracion_fisica.resultados (string detallado)
diagnostico.relacionado_con_otro (boolean)
diagnostico.especifique_cual (string)
intervencion_qx.tecnica (string - descripci√≥n t√©cnica quir√∫rgica)
intervencion_qx.utilizo_equipo_especial (boolean)
intervencion_qx.detalle_equipo_especial (string)
intervencion_qx.utilizo_insumos (boolean)
intervencion_qx.detalle_insumos (string)
complicaciones.descripcion (string - ya existe, solo asegurar mapeo)
padecimiento_actual.estado_actual (string)
padecimiento_actual.seguira_tratamiento (boolean)
padecimiento_actual.plan_tratamiento (string)
padecimiento_actual.fecha_probable_alta (string)
Secci√≥n 4 (Hospitalizaci√≥n):
hospital.tipo_estancia (string: "Urgencia" | "Hospitalario" | "Corta estancia")
Secci√≥n 6 (Equipo Quir√∫rgico):
Ya existe equipo_quirurgico_metlife con 4 profesionales, pero asegurar:

PersonalQuirurgico.especialidad (para los campos "Otro 1" y "Otro 2")
Secci√≥n 6 (Datos del M√©dico):
medico_tratante.tipo_atencion (string: "Tratante" | "Cirujano" | "Anestesi√≥logo" | "Ayudante" | "Otro")
medico_tratante.domicilio_consultorio (string)
medico_tratante.convenio_aseguradora (boolean - ya existe)
medico_tratante.se_ajusta_tabulador (boolean - ya existe)
Presupuesto desglosado (ya existente pero validar):
honorarios_cirujano
honorarios_anestesiologo
honorarios_ayudante
honorarios_otro_1
honorarios_otro_2
Secci√≥n 7 (Firma):
Ya existe fragmentado: firma.lugar, firma.fecha, firma.nombre_firma
üõ†Ô∏è PLAN DE IMPLEMENTACI√ìN
PASO 1: Crear services/providerConfigs.ts
Archivo NUEVO que contendr√°:

// ESTRUCTURA ESPERADA (no copies esto literalmente, ad√°ptalo):
interface ProviderConfig {
  id: 'GNP' | 'METLIFE';
  name: string;
  theme: { primary, secondary, border, light, accent };
  requiredFields: string[]; // Paths obligatorios
  geminiSchema: GeminiSchemaType; // Schema espec√≠fico para Gemini
  scoringRules: ScoringRule[]; // Reglas espec√≠ficas
  uiSections: UISection[]; // Tabs y campos para renderizar
}
export const PROVIDER_REGISTRY: Record<'GNP' | 'METLIFE', ProviderConfig>;
Contenido detallado:

GNP Config: Campos actuales + signos vitales espec√≠ficos
MetLife Config: TODOS los 50+ campos del formulario oficial (Secciones 1-7)
PASO 2: Actualizar types.ts
Agregar SOLO los campos nuevos identificados arriba (aprox. ~15 campos).

NO elimines campos existentes, solo expande las interfaces:

AntecedentesData ‚Üí agregar otras_afecciones
IntervencionQxData ‚Üí agregar booleanos y detalles de equipo/insumos
PadecimientoActualData ‚Üí agregar plan de tratamiento y fecha alta
HospitalData ‚Üí agregar tipo_estancia
MedicoTratanteData ‚Üí agregar tipo_atencion, domicilio_consultorio
PASO 3: Actualizar geminiService.ts
Cambio clave: En lugar de un responseSchema hardcoded, consumir desde providerConfigs:

// EJEMPLO CONCEPTUAL (no copies literal):
import { PROVIDER_REGISTRY } from './providerConfigs';
export const analyzeReportImage = async (base64Data, mimeType, detectedProvider) => {
  const config = PROVIDER_REGISTRY[detectedProvider];
  
  const response = await ai.models.generateContent({
    // ...
    responseSchema: config.geminiSchema // <-- Schema din√°mico
  });
}
PASO 4: Actualizar scoring-engine.ts
Expandir DEFAULT_SCORING_RULES con reglas espec√≠ficas de MetLife:

Nuevas reglas sugeridas:

metlife_equipo_qx_incompleto (20 pts) ‚Üí Valida que haya al menos Cirujano + Anestesi√≥logo con RFC
metlife_plan_tratamiento (10 pts) ‚Üí Si seguira_tratamiento=true, debe haber plan_tratamiento
metlife_tipo_estancia (5 pts) ‚Üí Campo obligatorio en hospitalizaci√≥n
PASO 5: Actualizar Dashboard.tsx
Renderizado din√°mico por secciones usando providerConfigs:

// EJEMPLO CONCEPTUAL:
import { PROVIDER_REGISTRY } from '../services/providerConfigs';
const Dashboard = ({ report }) => {
  const config = PROVIDER_REGISTRY[report.extracted.provider];
  
  return (
    <div>
      {config.uiSections.map(section => (
        <SectionRenderer key={section.id} fields={section.fields} />
      ))}
    </div>
  );
}
Nuevas secciones espec√≠ficas a agregar:

Tab "Equipo Qx": Renderizar los 4 profesionales (Anestesi√≥logo, Ayudante, Otros)
Tab "Padecimiento": Agregar checkboxes de equipo especial, insumos, seguimiento
Tab "Hospital": Select para tipo de estancia
PASO 6: Actualizar constants.ts
Expandir SYSTEM_PROMPT con instrucciones m√°s detalladas para MetLife:

Agregar secciones:

C√≥mo extraer campos de intervenci√≥n quir√∫rgica (equipo/insumos)
C√≥mo mapear el equipo quir√∫rgico completo (4 profesionales)
Validaci√≥n de completitud por secci√≥n
‚úÖ CRITERIOS DE ACEPTACI√ìN
ProviderRegistry funcional: Un solo archivo controla schemas, reglas y UI
50+ campos MetLife: Todos mapeados en types.ts y geminiService.ts
UI adaptativa: Dashboard renderiza campos seg√∫n providerConfigs
Scoring espec√≠fico: Reglas de MetLife validan RFC, equipo Qx, etc.
Sin romper GNP: Los informes GNP siguen funcionando igual
üö® RESTRICCIONES IMPORTANTES
NO elimines c√≥digo existente que funciona para GNP
NO hagas cambios arquitect√≥nicos fuera de lo descrito
S√ç mant√©n compatibilidad con el sistema actual de scoring
S√ç usa TypeScript estricto para evitar errores en runtime
üí° LIBERTAD DE IMPLEMENTACI√ìN
Si tienes una forma m√°s √≥ptima o eficiente de lograr esto, tienes total libertad de implementarla. El plan anterior es una sugerencia basada en nuestra discusi√≥n, pero si encuentras un camino m√°s limpio que:

Centralice configuraciones por proveedor
Mantenga el flujo ProviderRegistry ‚Üí Services ‚Üí UI
Escale f√°cilmente para agregar nuevas aseguradoras
¬°Adelante! Prop√≥n tu soluci√≥n. üöÄ

üìé ARCHIVOS DE REFERENCIA
types.ts ‚Üí Interfaces base (expandir)
geminiService.ts ‚Üí Consumir schemas del registry
scoring-engine.ts ‚Üí Agregar reglas MetLife
Dashboard.tsx ‚Üí Renderizado din√°mico
constants.ts ‚Üí Prompt de extracci√≥n