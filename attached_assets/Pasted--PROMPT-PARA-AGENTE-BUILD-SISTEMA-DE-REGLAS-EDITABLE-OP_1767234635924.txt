üöÄ PROMPT PARA AGENTE BUILD - SISTEMA DE REGLAS EDITABLE (OPCI√ìN C MEDIUM)
üìã CONTEXTO DEL PROYECTO
Est√°s trabajando en un Auditor M√©dico IA que valida informes m√©dicos para aseguradoras mexicanas. Actualmente tiene un sistema de reglas de validaci√≥n hardcodeadas en archivos .ts que necesita evolucionar a un sistema editable desde la UI.

Sistema Actual de Reglas:
Archivos actuales:

services/scoring-rules-general.ts - Reglas que aplican a TODAS las aseguradoras
services/scoring-rules-gnp.ts - Reglas espec√≠ficas de GNP
services/scoring-rules-metlife.ts - Reglas espec√≠ficas de MetLife
Componente UI actual:

RuleConfigurator.tsx - Modal que permite editar severidad y puntos de reglas existentes, pero NO crear nuevas.
üéØ OBJETIVO PRINCIPAL
Implementar la Opci√≥n C (Nivel Medium) del sistema de reglas:

‚úÖ Permitir crear nuevas reglas desde la UI
‚úÖ Editar reglas existentes (incluyendo condiciones, no solo puntos/severidad)
‚úÖ Condiciones AND/OR simples (un solo nivel, sin anidaci√≥n)
‚úÖ 21 operadores de validaci√≥n (listados abajo)
‚úÖ Preview en tiempo real de si la regla pasa/falla con los datos del reporte actual
‚úÖ Funcionar tanto para reglas generales como espec√≠ficas de aseguradora
üìä OPERADORES A IMPLEMENTAR (21 TOTAL)
Grupo 1: Validaci√≥n de Existencia (4)
IS_EMPTY - Campo vac√≠o
IS_NOT_EMPTY - Campo tiene valor
REQUIRES - Bidireccional (Si A existe, B debe existir Y viceversa)
IF_THEN - Unidireccional (Si A existe, entonces B debe existir, pero B puede existir sin A)
Grupo 2: Comparaci√≥n de Valores (4)
EQUALS - Igual a valor espec√≠fico
NOT_EQUALS - Diferente a valor
GREATER_THAN - Mayor que (num√©rico)
LESS_THAN - Menor que (num√©rico)
Grupo 3: Fechas (5)
DATE_MISSING - Fecha faltante
DATE_INVALID - Formato de fecha inv√°lido
IS_DATE - Valida que sea fecha v√°lida
DATE_BEFORE - Fecha A debe ser antes que Fecha B
DATE_AFTER - Fecha A debe ser despu√©s que Fecha B
Grupo 4: Formatos Espec√≠ficos (5)
IS_NUMBER - Es num√©rico
IS_EMAIL - Formato email v√°lido
IS_RFC - Formato RFC mexicano (13 caracteres alfanum√©ricos)
IS_PHONE - Formato tel√©fono (10 d√≠gitos)
REGEX - Patr√≥n regex custom
Grupo 5: L√≥gica M√∫ltiple (3)
MUTUALLY_EXCLUSIVE - Solo A o B puede existir, no ambos
ONE_OF_REQUIRED - Al menos 1 campo de una lista debe tener valor
ALL_REQUIRED - Todos los campos de una lista deben tener valor
‚öôÔ∏è DECISIONES T√âCNICAS TOMADAS
1Ô∏è‚É£ UI del RuleConfigurator:
Agregar bot√≥n de l√°piz (editar) en cada fila de regla existente, despu√©s de la columna "Categor√≠a"
Agregar bot√≥n "Crear Nueva Regla" arriba de la tabla de reglas
Al hacer clic en cualquiera de los dos, abrir un modal/drawer secundario con el editor de reglas
2Ô∏è‚É£ Persistencia de Reglas:
MANTENER LA L√ìGICA ACTUAL: Las reglas editadas/creadas se guardar√°n en localStorage del navegador (como lo hace actualmente RuleConfigurator con onUpdateRules).

Raz√≥n: Es m√°s simple, no requiere escribir archivos .ts din√°micamente, y las reglas personalizadas se cargan al iniciar la app desde localStorage.

Flujo:

RuleConfigurator ‚Üí onUpdateRules(newRules) ‚Üí App.tsx actualiza state 
‚Üí Se guarda en localStorage ‚Üí Se carga al refrescar p√°gina
3Ô∏è‚É£ Condiciones M√∫ltiples:
Solo un nivel (sin anidaci√≥n): Permitir A AND B AND C o A OR B OR C
NO permitir: (A AND B) OR (C AND D) (esto es High, no Medium)
Cada regla tendr√° un array de condiciones y un operador l√≥gico global (AND o OR)
4Ô∏è‚É£ Preview en Tiempo Real:
El preview mostrar√° solo si la regla pasa/falla con los datos actuales del reporte cargado.

Ejemplo de preview:

‚úÖ PASA: El reporte actual tiene "diagn√≥stico.diagnostico_definitivo" lleno
‚ùå FALLA: El campo "medico_tratante.rfc" est√° vac√≠o
NO incluir en Medium (quedan para High si se necesitan despu√©s):

‚ùå Sugerencias inteligentes de mejora
‚ùå An√°lisis de campos afectados en otros reportes
üèóÔ∏è ARQUITECTURA PROPUESTA
Nueva estructura de tipos:
// En types.ts
export interface RuleCondition {
  id: string;
  field: string; // ej: "diagnostico.diagnostico_definitivo"
  operator: RuleOperator;
  value?: string | number; // Para operadores como EQUALS, GREATER_THAN
  compareField?: string; // Para operadores como DATE_BEFORE (comparar 2 campos)
}
export type RuleOperator = 
  | 'IS_EMPTY' | 'IS_NOT_EMPTY' | 'REQUIRES' | 'IF_THEN'
  | 'EQUALS' | 'NOT_EQUALS' | 'GREATER_THAN' | 'LESS_THAN'
  | 'DATE_MISSING' | 'DATE_INVALID' | 'IS_DATE' | 'DATE_BEFORE' | 'DATE_AFTER'
  | 'IS_NUMBER' | 'IS_EMAIL' | 'IS_RFC' | 'IS_PHONE' | 'REGEX'
  | 'MUTUALLY_EXCLUSIVE' | 'ONE_OF_REQUIRED' | 'ALL_REQUIRED';
export type LogicOperator = 'AND' | 'OR';
export interface ScoringRule {
  id: string;
  name: string;
  level: 'CR√çTICO' | 'IMPORTANTE' | 'MODERADO' | 'DISCRETO';
  points: number;
  description: string;
  providerTarget: 'ALL' | ProviderType;
  
  // Nueva estructura de condiciones
  conditions: RuleCondition[];
  logicOperator: LogicOperator; // Como combinar las condiciones
  
  // Mantener compatibilidad con reglas antiguas
  validator?: (data: ExtractedData) => boolean;
  affectedFields: string[];
}
Nuevo componente: RuleEditor
Crear components/RuleEditor.tsx que ser√° un modal/drawer con:

Secci√≥n de Metadatos:

Nombre de la regla (input text)
Descripci√≥n (textarea)
Nivel de severidad (select: CR√çTICO/IMPORTANTE/MODERADO/DISCRETO)
Puntos (input number)
Aseguradora objetivo (select: ALL/GNP/METLIFE)
Secci√≥n de Condiciones:

Bot√≥n "+ Agregar Condici√≥n"
Lista de condiciones existentes (editable/borrable)
Cada condici√≥n muestra:
Campo (autocomplete con paths del schema, ej: diagnostico.diagnostico_definitivo)
Operador (select con los 21 operadores)
Valor/Campo de comparaci√≥n (seg√∫n el operador elegido)
Operador L√≥gico Global:

Radio buttons: AND o OR
Preview en Tiempo Real:

Caja que muestra: "‚úÖ Esta regla PASA" o "‚ùå Esta regla FALLA"
Ejecutar validaci√≥n contra report.extracted (si hay un reporte cargado)
Botones de Acci√≥n:

"Guardar Regla" (cierra el editor y actualiza rules)
"Cancelar" (cierra sin guardar)
üõ†Ô∏è TAREAS ESPEC√çFICAS
Tarea 1: Actualizar types.ts
Agregar interfaces RuleCondition, RuleOperator, LogicOperator
Actualizar interfaz ScoringRule para incluir conditions y logicOperator
Mantener compatibilidad hacia atr√°s con validator opcional
Tarea 2: Crear components/RuleEditor.tsx
Modal/drawer con todas las secciones descritas arriba
Props:
interface RuleEditorProps {
  isOpen: boolean;
  onClose: () => void;
  rule?: ScoringRule; // Si es undefined = crear nueva, si existe = editar
  onSave: (rule: ScoringRule) => void;
  currentReport?: ExtractedData; // Para el preview
}
Tarea 3: Crear services/rule-validator.ts
Funci√≥n validateRule(rule: ScoringRule, data: ExtractedData): boolean
Implementar la l√≥gica para cada uno de los 21 operadores
Combinar condiciones con AND/OR seg√∫n rule.logicOperator
Ejemplo:
export function validateRule(rule: ScoringRule, data: ExtractedData): boolean {
  if (rule.validator) {
    // Compatibilidad con reglas antiguas
    return rule.validator(data);
  }
  
  const results = rule.conditions.map(cond => 
    validateCondition(cond, data)
  );
  
  if (rule.logicOperator === 'AND') {
    return results.every(r => r);
  } else {
    return results.some(r => r);
  }
}
function validateCondition(cond: RuleCondition, data: ExtractedData): boolean {
  const fieldValue = getNestedField(data, cond.field);
  
  switch (cond.operator) {
    case 'IS_EMPTY':
      return !fieldValue || fieldValue === '';
    case 'IS_NOT_EMPTY':
      return !!fieldValue && fieldValue !== '';
    case 'EQUALS':
      return fieldValue === cond.value;
    // ... implementar los otros 18 operadores
  }
}
Tarea 4: Actualizar RuleConfigurator.tsx
Agregar bot√≥n "Crear Nueva Regla" arriba de la tabla
Agregar columna de "Acciones" con bot√≥n de l√°piz (editar) en cada fila
Integrar RuleEditor:
const [editingRule, setEditingRule] = useState<ScoringRule | undefined>();
const [isEditorOpen, setIsEditorOpen] = useState(false);
// Al hacer clic en "Crear Nueva Regla"
<button onClick={() => {
  setEditingRule(undefined); // undefined = crear nueva
  setIsEditorOpen(true);
}}>
  + Crear Nueva Regla
</button>
// Al hacer clic en el l√°piz de una regla
<button onClick={() => {
  setEditingRule(rule);
  setIsEditorOpen(true);
}}>
  <Edit className="w-4 h-4" />
</button>
// Modal
<RuleEditor 
  isOpen={isEditorOpen}
  onClose={() => setIsEditorOpen(false)}
  rule={editingRule}
  onSave={(newRule) => {
    // Si editingRule existe, reemplazarlo; si no, agregarlo
    const updatedRules = editingRule
      ? rules.map(r => r.id === editingRule.id ? newRule : r)
      : [...rules, newRule];
    onUpdateRules(updatedRules);
    setIsEditorOpen(false);
  }}
  currentReport={/* pasar el report.extracted desde App.tsx si existe */}
/>
Tarea 5: Actualizar scoring-engine.ts
Modificar calculateScore para usar validateRule del nuevo servicio
Mantener compatibilidad con reglas antiguas (que tienen validator)
Tarea 6: Persistencia en localStorage
En App.tsx, al llamar onUpdateRules, guardar en localStorage:
const handleRulesUpdate = (newRules: ScoringRule[]) => {
  setRules(newRules);
  localStorage.setItem('custom-rules', JSON.stringify(newRules));
  // Re-evaluar score si hay reporte cargado
  if (report && status === 'complete') {
    const updatedReport = await reEvaluateReport(report, report.extracted, newRules);
    setReport(updatedReport);
  }
};
// Al cargar la app (useEffect en App.tsx)
useEffect(() => {
  const savedRules = localStorage.getItem('custom-rules');
  if (savedRules) {
    const parsed = JSON.parse(savedRules);
    setRules([...DEFAULT_SCORING_RULES, ...parsed]); // Combinar con defaults
  }
}, []);
üé® CONSIDERACIONES DE UX
Campo autocomplete:

Al elegir el campo de una condici√≥n, mostrar lista de paths disponibles del schema
Ejemplo: diagnostico.diagnostico_definitivo, medico_tratante.rfc, etc.
Operadores contextuales:

Si el campo seleccionado es de tipo fecha, mostrar solo operadores de fecha
Si es num√©rico, mostrar solo operadores num√©ricos/comparaci√≥n
Si es string, mostrar solo operadores de string/regex
Preview en vivo:

Actualizar el preview cada vez que el usuario cambie una condici√≥n
Mostrar mensaje claro: "‚úÖ PASA" o "‚ùå FALLA"
Si no hay reporte cargado, mostrar: "‚ö†Ô∏è Sube un reporte para previsualizar"
Validaci√≥n del formulario:

No permitir guardar si falta nombre o descripci√≥n
No permitir condiciones incompletas (campo sin operador, etc.)
üö® IMPORTANTE
Estos procesos son una SUGERENCIA. Si encuentras una forma m√°s √≥ptima o eficiente de implementar esto, tienes libertad total para hacerlo.
Mant√©n compatibilidad hacia atr√°s: Las reglas antiguas con validator deben seguir funcionando.
Prioriza simplicidad: Este es nivel Medium, no agregues complejidad innecesaria.
üìù PREGUNTAS FINALES PARA TI (AGENTE BUILD)
¬øNecesitas m√°s contexto sobre alg√∫n archivo espec√≠fico?
¬øHay alguna parte de la arquitectura que no te quede clara?
¬øPrefieres implementar esto en fases (ej: primero los operadores b√°sicos, luego los avanzados)?
Procede con la implementaci√≥n cuando est√©s listo. üöÄ