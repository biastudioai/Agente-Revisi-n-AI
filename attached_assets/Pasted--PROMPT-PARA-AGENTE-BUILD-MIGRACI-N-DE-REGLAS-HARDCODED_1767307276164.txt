ğŸ¯ PROMPT PARA AGENTE BUILD: MIGRACIÃ“N DE REGLAS HARDCODED A SISTEMA EDITABLE
ğŸ“‹ CONTEXTO DEL PROYECTO
EstÃ¡s trabajando en un Auditor MÃ©dico IA que valida informes mÃ©dicos de diferentes aseguradoras (GNP, MetLife). Actualmente el sistema tiene:

Reglas hardcoded con funciones validator en:

services/scoring-rules-general.ts (3 reglas generales)
services/scoring-rules-gnp.ts (3 reglas especÃ­ficas GNP)
services/scoring-rules-metlife.ts (3 reglas especÃ­ficas MetLife)
Sistema nuevo de reglas editables con:

21 operadores en services/rule-validator.ts
Editor visual en components/RuleEditor.tsx
Sistema de condiciones (RuleCondition[]) + lÃ³gica AND/OR
ğŸ¯ OBJETIVO PRINCIPAL
MIGRAR todas las reglas hardcoded (9 reglas totales) al sistema de condiciones editables, eliminando las funciones validator y reemplazÃ¡ndolas por arrays de conditions.

âœ… REGLAS A MIGRAR
REGLAS GENERALES (3 reglas - archivo scoring-rules-general.ts):
diag_falta: DiagnÃ³stico definitivo vacÃ­o

Operador sugerido: IS_EMPTY
Campo: diagnostico.diagnostico_definitivo
cie_incoherencia: CIE-10 no coherente con texto

Operador sugerido: EQUALS (comparar con false)
Campo: diagnostico.cie_coherente_con_texto
Valor: false
firma_faltante: Firma autÃ³grafa no detectada

Operador sugerido: EQUALS (comparar con false)
Campo: firma.firma_autografa_detectada
Valor: false
REGLAS GNP (3 reglas - archivo scoring-rules-gnp.ts):
gnp_signos: Signos vitales incompletos (falta presiÃ³n O temperatura)

Operador sugerido: ONE_OF_REQUIRED (al menos uno debe estar vacÃ­o)
Campos: ['signos_vitales.presion_arterial', 'signos_vitales.temperatura']
LÃ³gica: OR (si cualquiera falta, se activa)
gnp_cedula: CÃ©dula profesional invÃ¡lida (debe ser 7-8 dÃ­gitos)

Operador sugerido: REGEX (negado - si NO cumple el patrÃ³n)
Campo: medico_tratante.cedula_profesional
Valor regex: ^\d{7,8}$
gnp_fechas_hospital: Fechas de hospitalizaciÃ³n incompletas

Esta es COMPLEJA - requiere 2 condiciones con lÃ³gica AND:
CondiciÃ³n 1: hospital.tipo_estancia CONTAINS "ingreso" O "hospital"
CondiciÃ³n 2: hospital.fecha_ingreso IS_EMPTY O hospital.fecha_egreso IS_EMPTY
SoluciÃ³n recomendada: Simplificar a solo validar fechas vacÃ­as (sin lÃ³gica condicional del tipo_estancia)
REGLAS METLIFE (3 reglas - archivo scoring-rules-metlife.ts):
metlife_rfc: RFC mÃ©dico obligatorio vacÃ­o

Operador sugerido: IS_EMPTY
Campo: medico_tratante.rfc
metlife_secciones: Secciones incompletas (historia clÃ­nica O padecimiento vacÃ­os)

Operador sugerido: ONE_OF_REQUIRED
Campos: ['antecedentes.historia_clinica_breve', 'padecimiento_actual.descripcion']
metlife_codigo_cie: CÃ³digo CIE-10 formato invÃ¡lido

Operador sugerido: REGEX (negado)
Campo: diagnostico.codigo_cie
Valor regex: ^[A-Z]\d{2}(\.\d{1,2})?$
ğŸ› ï¸ TAREAS TÃ‰CNICAS
PASO 1: Actualizar archivos de reglas
Reemplaza las 9 reglas en los 3 archivos eliminando validator y agregando conditions:

// EJEMPLO DE CONVERSIÃ“N:
// ANTES (hardcoded):
{
  id: 'diag_falta',
  validator: (data) => !data.diagnostico?.diagnostico_definitivo?.trim(),
  affectedFields: ['diagnostico.diagnostico_definitivo']
}
// DESPUÃ‰S (editable):
{
  id: 'diag_falta',
  conditions: [
    {
      id: 'cond_diag_1',
      field: 'diagnostico.diagnostico_definitivo',
      operator: 'IS_EMPTY'
    }
  ],
  logicOperator: 'AND',
  affectedFields: ['diagnostico.diagnostico_definitivo']
}
PASO 2: Verificar compatibilidad en rule-validator.ts
El sistema ya soporta reglas hÃ­bridas:

export function validateRule(rule: ScoringRule, data: ExtractedData): boolean {
  // 1. Si tiene validator (legacy), Ãºsalo
  if (rule.validator) {
    return rule.validator(data);
  }
  
  // 2. Si tiene conditions (nuevo sistema), Ãºsalas
  if (rule.conditions && rule.conditions.length > 0) {
    const results = rule.conditions.map(cond => validateCondition(cond, data));
    return rule.logicOperator === 'OR' 
      ? results.some(r => r) 
      : results.every(r => r);
  }
  
  return false;
}
NO necesitas modificar rule-validator.ts - ya estÃ¡ preparado.

PASO 3: UX/UI - Mejores PrÃ¡cticas
Para que las reglas sean editables desde la UI, asegÃºrate de que:

Todas las reglas tienen isCustom: false (para diferenciarlas de reglas creadas por el usuario)
El botÃ³n "Editar" funciona para reglas del sistema (actualmente solo funciona para isCustom: true)
El RuleEditor muestra correctamente las condiciones existentes al editar
Cambios sugeridos en RuleConfigurator.tsx:

Permitir editar TODAS las reglas (no solo isCustom)
Agregar badge visual "SISTEMA" vs "CUSTOM"
Mantener botÃ³n "Eliminar" solo para reglas custom
ğŸ“¦ ENTREGABLES ESPERADOS
âœ… Archivo services/scoring-rules-general.ts actualizado (3 reglas con conditions)
âœ… Archivo services/scoring-rules-gnp.ts actualizado (3 reglas con conditions)
âœ… Archivo services/scoring-rules-metlife.ts actualizado (3 reglas con conditions)
âœ… Archivo components/RuleConfigurator.tsx modificado para permitir editar reglas del sistema
âœ… Todas las reglas funcionando igual que antes (validaciÃ³n correcta)
âš ï¸ CASOS ESPECIALES
Regla compleja: gnp_fechas_hospital
Esta regla tiene lÃ³gica condicional (valida fechas SOLO si es hospitalario):

OPCIÃ“N A (Simplificada - RECOMENDADA):

conditions: [
  { field: 'hospital.fecha_ingreso', operator: 'IS_EMPTY' },
  { field: 'hospital.fecha_egreso', operator: 'IS_EMPTY' }
],
logicOperator: 'OR'  // Falla si cualquiera estÃ¡ vacÃ­o
OPCIÃ“N B (Completa - REQUIERE NUEVO OPERADOR):
Si quieres mantener la lÃ³gica exacta (validar solo si es hospitalario), necesitarÃ­as crear un operador CONTAINS nuevo. NO LO HAGAS a menos que el usuario lo pida explÃ­citamente.

ğŸ¨ REFERENCIA VISUAL
DespuÃ©s de la migraciÃ³n, todas las reglas deberÃ­an verse asÃ­ en RuleEditor:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DiagnÃ³stico faltante                    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ 1  diagnostico.diagnostico_definitivo â”‚
â”‚ â”‚    EstÃ¡ vacÃ­o (falta valor)       â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚ Combinar: Y (AND)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ğŸš€ INSTRUCCIONES FINALES
Revisa cada regla antes de migrarla para elegir el operador correcto
Genera IDs Ãºnicos para cada condiciÃ³n (formato: cond_${timestamp}_${random})
Prueba la validaciÃ³n con datos reales para confirmar que funciona igual
MantÃ©n los affectedFields exactos (el Dashboard los usa para resaltar campos)
NO modifiques rule-validator.ts - el sistema ya es compatible
Simplifica la lÃ³gica compleja cuando sea posible (UX > perfecciÃ³n tÃ©cnica)
ğŸ’¡ LIBERTAD CREATIVA
Si encuentras una forma mÃ¡s Ã³ptima o eficiente de realizar esta migraciÃ³n (por ejemplo, usando un operador diferente que sea mÃ¡s semÃ¡ntico), tienes total libertad para proponer una mejor soluciÃ³n. Lo importante es que:

âœ… Las 9 reglas queden editables desde la UI
âœ… La validaciÃ³n funcione correctamente
âœ… El cÃ³digo sea mantenible y legible